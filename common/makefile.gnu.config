# These definitions are generated by the kit builder
KIT=1
TARGET_OS=l

##############################################################
#
# Here are some things you might want to configure
#
##############################################################

#is there a better place to put this? -cpc
#i want to specify the total amount of memory available
#CFLAGS += -DTOTAL_DRAM_MEMORY_BYTES="(pow(2,32))"

# Override the host architecture so we always build for 32-bit
TARGET=ia32

# 0 means off; 1 means on
DEBUG = 1

# if your tool is not in the kit directory
# then set this to the pin-2.0-X-Y directory
TMP=$(shell uname -m)
ifeq (${TMP},x86_64)
  PIN_HOME ?= /afs/csail/group/carbon/tools/pin/pin-2.5-24110-gcc.4.0.0-ia32_intel64-linux
else
  PIN_HOME ?= /afs/csail/group/carbon/tools/pin/pin-2.5-24110-gcc.4.0.0-ia32_intel64-linux
endif

PIN_KIT ?= $(PIN_HOME)

# Select static or dynamic linking for tool
# only applies to unix
#PIN_DYNAMIC = -static
PIN_DYNAMIC = -ldl

#<<<<<<< HEAD:common/makefile.gnu.config
#below is shared memory code... hopefully mpi compilers are good enough -cpc
#### Local CAG customizations ####

# Manually specify correct version of GCC
#CC = /usr/bin/gcc
#CXX = /usr/bin/g++

#IN SHARED MEMORY why was this here?
#export LD_LIBRARY_PATH = /usr/lib
#=======
# Added for MPI support
MPI_VERSION = 1.3-debug
MPI_DIR = /afs/csail/group/carbon/tools/openmpi/install-$(MPI_VERSION)/$(TARGET)
#MPI_DIR = /afs/csail/group/carbon/tools/openmpi
export LD_LIBRARY_PATH := $(MPI_DIR)/lib  ####:$(LD_LIBRARY_PATH)
CC = $(MPI_DIR)/bin/mpicc
CXX = $(MPI_DIR)/bin/mpicxx
#>>>>>>> master:common/makefile.gnu.config

######## NOTE ########
# Probe mode has been disabled below because it doesn't work
# with current Linux distributions. (jasonm)
######################


##############################################################
#
# Typical users will not need to change the stuff below here
#
##############################################################

##############################################################
# Set things for all architectures and all OS
##############################################################
ifeq ($(DEBUG),1)
  DBG = -g
else
  DBG =
endif

PIN_CXXFLAGS   = -DBIGARRAY_MULTIPLIER=1 -DUSING_XED $(DBG)
PIN_CXXFLAGS  += -fno-strict-aliasing -I$(PIN_HOME)/source/include -I$(PIN_HOME)/source/tools/InstLib
PIN_LPATHS     = -L$(PIN_HOME)/Lib/ -L$(PIN_HOME)/ExtLib/
PIN_BASE_LIBS := 
PIN_LDFLAGS    = $(DBG)
NO_LOGO        =
SSE2           = -msse2
ENABLE_VS      = 0
# Disabled for compatibility with current Linux distros (jasonm)
PROBE          = 0
#PROBE          = 1
AS_FLAGS       =
ASLD_FLAGS     =


ifeq ($(CCOV),1)
  # code coverage is on
  PIN_LDFLAGS += -prof-genx
  ifneq ($(CCOVDIR),)
    PIN_LDFLAGS += -prof-dir $(CCOVDIR)
  endif
endif

ifeq ($(ENABLE_VS),1)
    VIRT_SEG_FLAG  = -xyzzy -241runtime 0 -xyzzy -virtual_segments 1
else
    VIRT_SEG_FLAG  =
endif

ifndef HOST_ARCH
    # default to building for the host you are on. You can override this on the cmd line.
    HST=$(shell uname -m)
    ifeq (${HST},x86_64)
        HOST_ARCH=ia32e
    endif
    ifeq (${HST},amd64)
        HOST_ARCH=ia32e
    endif
    ifeq (${HST},i686)
        HOST_ARCH=ia32
    endif
    ifeq (${HST},x86)
        HOST_ARCH=ia32
    endif
    ifeq (${HST},i386)
        HOST_ARCH=ia32
    endif
    ifeq (${HST},ia64)
        HOST_ARCH=ipf
    endif
endif
ifndef HOST_ARCH
    $(could not detect building host. please define HOST_ARCH on the command line)       
endif

ifndef TARGET
		TARGET=${HOST_ARCH}
endif

#define TARGET_LONG
ifeq (${TARGET},ia32e)
    TARGET_LONG=intel64
endif
ifeq (${TARGET},ia32)
    TARGET_LONG=ia32
endif
ifeq (${TARGET},ipf)
    TARGET_LONG=ia64
endif
ifndef TARGET_LONG
    $(error unknown TARGET, could not define TARGET_LONG)       
endif
##############################################################
# Set the kit versus source tree stuff
##############################################################
ifndef KIT
    KIT = 0
endif
ifndef OVERRIDE_DEFAULT_COMPILER
    OVERRIDE_DEFAULT_COMPILER = 0
endif

ifeq (${KIT},0)

    #
    # Building out of a source tree
    #

    OS=$(shell uname -s)

    ifeq ($(findstring CYGWIN,$(OS)),CYGWIN)
        BUILD_OS = w
        TARGET_OS = w
        TARGET_OS_LONG = windows
    else
        ifeq ($(OS),Darwin)
            BUILD_OS = m
            TARGET_OS = m
            TARGET_OS_LONG = mac
        else
            BUILD_OS = l
            TARGET_OS = l
            TARGET_OS_LONG = linux
        endif
    endif

    ifeq (${HOST_ARCH},ia32e)
         TARGET_EXT = ia32_intel64
    else
         TARGET_EXT = $(TARGET_LONG)
    endif

    # If you are building out of a source tree and not a kit
    # point this to the charm directory
    PIN_ROOT ?= ../..

    XEDKIT = $(PIN_ROOT)/build/Source/xed/export-$(TARGET_OS_LONG)-$(TARGET_LONG)/xed2-kit
    PIN_CXXFLAGS += -I$(XEDKIT)/include \
                    -I$(PIN_ROOT)/build/Source/pin/pin-W-X-Y-$(TARGET_EXT)-$(TARGET_OS_LONG)/source/include/gen \
                    -I$(PIN_ROOT)/build/Source/pin/pin-W-X-Y-$(TARGET_EXT)-$(TARGET_OS_LONG)/source/include

    # TODO: add option to pass only ICCVER and find the path to icc from it
    ifneq ($(ICCDIR),)
        CXX = $(ICCDIR)/icpc
        CC = $(ICCDIR)/icc
        APP_CXXLINK_FLAGS = -i_static -Wl,-rpath=/usr/intel/pkgs/gcc/4.2.0/lib
        PIN_LDFLAGS += -i_static -Wl,-rpath=/usr/intel/pkgs/gcc/4.2.0/lib
        PIN_CXXFLAGS += -i_static -gcc-version=420
        PIN_CXXFLAGS += -gcc-name=/usr/intel/pkgs/gcc/4.2.0/bin/gcc -gxx-name=/usr/intel/pkgs/gcc/4.2.0/bin/g++
        PIN_CXXFLAGS += -wd1418 -wd1419 -wd981 -wd383 -wd869 -wd593 -wd266 -wd279 -wd444 -wd168 -wd810 -wd810 -wd181
    endif


    TARGET_SPEC = ${TARGET}_${TARGET_OS}${TARGET_OFORMAT}
    PIN_LPATHS +=  -L$(PIN_ROOT)/build/Source/pin/pin-${TARGET_OS_LONG}-${TARGET_LONG} \
                   -L$(PIN_ROOT)/External/Libdwarf/Lib_${TARGET_SPEC} \
                   -L$(PIN_ROOT)/External/Libelf/Lib_${TARGET_SPEC} \
                   -L$(XEDKIT)/lib
    PIN_BIN = $(PIN_ROOT)/build/Source/pin/pin-${TARGET_OS_LONG}-${TARGET_LONG}/pin
    PIN =  ${PIN_BIN} -slow_asserts $(VIRT_SEG_FLAG) $(PIN_FLAGS) $(PIN_USERFLAGS)
    PIN_LIBNAMES =  $(PIN_ROOT)/build/Source/pin/pin-${TARGET_OS_LONG}-${TARGET_LONG}/libpin.a
    PINDB =  $(PIN_ROOT)/build/Source/pindb/export-${TARGET_OS_LONG}-${TARGET_LONG}/pindb

    OVERRIDE_DEFAULT_COMPILER = 1

    VSCRIPT_DIR = $(PIN_HOME)/Include/
else

    #
    # Building out of a kit
    #
    PIN_KIT ?= ../../..

    ifeq (${TARGET_OS},l)
        TARGET_OS_LONG=linux
    endif
    ifeq (${TARGET_OS},m)
        TARGET_OS_LONG=mac
    endif
    ifeq (${TARGET_OS},w)
        TARGET_OS_LONG=windows
    endif

    PIN = $(PIN_KIT)/pin -slow_asserts $(VIRT_SEG_FLAG) $(PIN_FLAGS) $(PIN_USERFLAGS)
    PINDB = LD_LIBRARY_PATH=$(PIN_KIT)/$(TARGET_LONG)/runtime:$$LD_LIBRARY_PATH $(PIN_KIT)/$(TARGET_LONG)/bin/pindb

    XEDKIT        = $(PIN_KIT)/extras/xed2-$(TARGET_LONG)
    PIN_LPATHS   += -L$(XEDKIT)/lib -L$(PIN_KIT)/$(TARGET_LONG)/lib -L$(PIN_KIT)/$(TARGET_LONG)/lib-ext
    PIN_CXXFLAGS += -I$(XEDKIT)/include -I$(PIN_KIT)/source/include -I$(PIN_KIT)/source/include/gen
    VSCRIPT_DIR = $(PIN_KIT)/source/include

endif

ifeq ($(OVERRIDE_DEFAULT_COMPILER),1)
    # We override CXX only if it is the default one from Make. 
    # Environment overrides of CXX take precidence.

    ifeq ($(TARGET),ipf)
        ifeq ($(origin CXX), default)
            CXX = /usr/intel/pkgs/gcc/3.4/bin/g++
        endif
        ifeq ($(origin CC), default)
            CC = /usr/intel/pkgs/gcc/3.4/bin/gcc
        endif
    endif

    ifeq ($(TARGET),ia32)
        ifeq ($(TARGET_OS),l)
            ifeq ($(origin CC), default)
                CC = /usr/intel/pkgs/gcc/4.2.0/bin/gcc
            endif
            ifeq ($(origin CXX), default)
                CXX = /usr/intel/pkgs/gcc/4.2.0/bin/g++
            endif
        endif
    endif

    ifeq ($(TARGET),ia32e)
        ifeq ($(TARGET_OS),l)
            ifeq ($(origin CXX), default)
                CXX = /usr/intel/pkgs/gcc/4.2.0/bin/g++
            endif
            ifeq ($(origin CC), default)
                CC = /usr/intel/pkgs/gcc/4.2.0/bin/gcc
            endif
        endif
    endif
        endif

##############################################################
# Set the architecture specific stuff
##############################################################

ifeq ($(TARGET),ia32)

    PIN_CXXFLAGS += -DTARGET_IA32
    APP_CXXFLAGS += -DTARGET_IA32
    APP_CXXFLAGS2 += -DTARGET_IA32
    #TOOLADDR=--section-start,.interp=0x70008400
    # The 400 in the address leaves room for the program headers

    ifeq ($(TARGET_OS),m)
        ### TOOLADDR setting for Mac
        # old value that works with MacOS 10.4.1: 0x50048000
        # old value that works for SPEC but not gui program: 0x16048000
        TOOLADDR = -Wl,-seg1addr -Wl,0x84048000
        PIN_BASE_LIBS += -lxed
        PIN_PTHREAD_LIBS = -lpinpthread
        ###  FIXMAC: __pthread_mutex_init is not yet redefined 
        #PIN_PTHREAD_LIBS_FLAGS = -Wl,-u,__pthread_mutex_init 
    else
        ### TOOLADDR setting for Linux and Windows
        TOOLADDR = -Wl,--section-start,.interp=0x05048400
        PIN_BASE_LIBS += -lxed
        PIN_PTHREAD_LIBS = -lpinpthread
        PIN_PTHREAD_LIBS_FLAGS = -Wl,-u,__pthread_mutex_init
    endif
endif

ifeq ($(TARGET),ia32)
		ifeq (${HOST_ARCH},ia32e)
				### IA32 on Intel64 compiler flags
				PIN_CXXFLAGS += -m32 
				PIN_LDFLAGS += -m32
				ASLD_FLAGS       = -m elf_i386
				AS_FLAGS     = --32
				TESTAPP = ../Tests/$(OBJDIR)cp-pin
				APP_CXXFLAGS += -m32
				APP_CXXFLAGS2 += -m32
				CC += -m32 
				CXX += -m32  
		endif
endif

ifeq ($(TARGET),ia32e)
    PIN_CXXFLAGS += -DTARGET_IA32E -DHOST_IA32E
    APP_CXXFLAGS += -DTARGET_IA32E
    APP_CXXFLAGS2 += -DTARGET_IA32E
    PIN_BASE_LIBS += -lxed
    PIN_BASE_LIBS += -lxed
    PIN_PTHREAD_LIBS = -lpinpthread
    PIN_PTHREAD_LIBS_FLAGS = -Wl,-u,__pthread_mutex_init
    TOOLADDR = -Wl,--section-start,.interp=0x20048000
endif

ifeq ($(TARGET),ipf)
    PIN_CXXFLAGS += -DTARGET_IPF -DHOST_IPF
    APP_CXXFLAGS += -DTARGET_IPF
    APP_CXXFLAGS2 += -DTARGET_IPF
    TOOLADDR = -Wl,--section-start,.interp=0x00000c0000000400,--section-start,.init_array=0x00000e0000000400,-defsym,__init_array_start=0x00000e0000000400,-defsym,__preinit_array_start=__init_array_start,-defsym,__preinit_array_end=__preinit_array_start
    PIN_PTHREAD_LIBS = -lpinpthread
    PIN_PTHREAD_LIBS_FLAGS = -Wl,-u,__pthread_mutex_init
endif

##############################################################
# Set the OS specific variables
#   Some of this refers to architecture dependent variables
#   so this must second
##############################################################

# Select tools to be shared objects on Linux
# Use ?= to allow the user to override it in the command line
ifeq ($(TARGET_OS),l)
    SOTOOL ?= 1
endif

ifeq ($(TARGET_OS),w)
### Windows

    PIN_CXXFLAGS += -DTARGET_WINDOWS -mno-cygwin

    #FIXME: make this conditional based on the compiler
    PIN_BASE_LIBS +=  -lpinvm -lntdll
    PIN_LDFLAGS += -Wl,--export-all-symbols
    PIN_LDFLAGS += -shared -Wl,-wrap,atexit,-wrap,_onexit,-e,_Ptrace_DllMainCRTStartup@12 -mno-cygwin
    PIN_LDFLAGS += -Wl,--image-base -Wl,0x55000000
    PINTOOL_SUFFIX = .dll
    ifndef TESTAPP
	    #TESTAPP = C:/cygwin/bin/cp.exe
	    TESTAPP = $(PIN_HOME)/Tests/cp-pin.exe
	  endif
    APP_CXXFLAGS += -DTARGET_WINDOWS -mno-cygwin
    PIN_CMP = cmp
    PIN_DIFF = diff -w
    APP_CXXFLAGS2 += -mno-cygwin
    EXEEXT = .exe
    OBJEXT = obj
else 
  ifeq ($(SOTOOL),1)
### Linux only
   
    PIN_CMP = cmp
    PIN_DIFF = ${PIN_CMP}

    # on intel64 and ipf shared-objects must be compiled with -fPIC
    ifneq ($(TARGET),ia32)
      PIN_CXXFLAGS += -fPIC
    endif

    PIN_BASE_LIBS += -ldwarf -lelf ${PIN_DYNAMIC}
    PIN_CXXFLAGS += -DTARGET_LINUX
    PIN_SOFLAGS =  -shared -Wl,-Bsymbolic -Wl,--version-script=$(VSCRIPT_DIR)/pintool.ver
    APP_CXXFLAGS += -DTARGET_LINUX

    # shared object tool don't need TOOLADDR
    TOOLADDR = 
    PINTOOL_SUFFIX=.so
    SATOOL_SUFFIX=
    EXEEXT=
    OBJEXT=o
    ifndef TESTAPP
      TESTAPP = /bin/cp
    endif
    PIN_SALDFLAGS := $(PIN_LDFLAGS)
    PIN_LDFLAGS += $(PIN_SOFLAGS)
  else
### Linux or Mac (tool is executable)
   
    # This enables the thread safe libc by pulling in pthread.o from libpinpthread.a
    # Otherwise, you will get the non threadsafe version from libc
    # It also pulls in malloc_st.o by using malloc
    ifeq ($(TARGET_OS),m)
        PIN_CMP = ../mac-cmp
    else
        PIN_CMP = cmp
    endif
    PIN_DIFF = ${PIN_CMP}
    ifeq ($(TARGET_OS),l)
        ### Linux
        PIN_BASE_LIBS += -ldwarf -lelf ${PIN_DYNAMIC}
        PIN_CXXFLAGS += -DTARGET_LINUX
        PIN_LDFLAGS += -Wl,-u,malloc
        APP_CXXFLAGS += -DTARGET_LINUX
    else
        ### Mac
        PIN_BASE_LIBS += $(PIN_PTHREAD_LIBS) ${PIN_DYNAMIC}
	    PIN_LDFLAGS += $(PIN_PTHREAD_LIBS_FLAGS)

        # The -lpinpthreads library refers to symbols in -lpin / -lsapin, so
        # add them a second time on the link line.
        PIN_BASE_LIBS_MAC = -lpin
        PIN_BASE_LIBS_MAC_SA = -lsapin

        # Suppress linker warnings
        PIN_LDFLAGS += -w -Wl,-multiply_defined -Wl,suppress
        PIN_CXXFLAGS += -DTARGET_MAC
        APP_CXXFLAGS += -DTARGET_MAC
    endif


    PIN_LDFLAGS += ${TOOLADDR} 
    PIN_SALDFLAGS = $(PIN_LDFLAGS)
    PINTOOL_SUFFIX =
    SATOOL_SUFFIX =
    EXEEXT =
    OBJEXT = o
    ifndef TESTAPP
      TESTAPP = /bin/cp
    endif
  endif
endif

ifeq ($(PIN_PIE),1)
  ifneq ($(SOTOOL),1)
    PIN_CXXFLAGS += -fPIE
    PIN_LDFLAGS += -pie -Wl,-Bsymbolic
    TOOLADDR =
  endif
endif

SAPIN_LIBS = -lsapin $(PIN_BASE_LIBS) $(PIN_BASE_LIBS_MAC_SA)
PIN_LIBS = -lpin $(PIN_BASE_LIBS) $(PIN_BASE_LIBS_MAC)

##############################################################
# Some final variables
##############################################################

# put the lpaths before all the libs
PIN_LDFLAGS +=  ${PIN_LPATHS}
OPT          = -O3 -fomit-frame-pointer
NO_OPTIMIZE  = -O0
COPT         = -c
OUTOPT       = -o 
OUTEXE       = -o 
LINK_OUT     = -o 

ifeq ($(DEBUG),0)
  PIN_CXXFLAGS += $(OPT)
endif

OBJDIR = obj-$(TARGET_LONG)/
PYTHON = python

##############################################################
# Rules to make testing easier
# This testing only checks that the application ran correctly.
# It does no checking of the results of the tool.
# If you make the tool self checking and exit with a non zero exit code, 
# then it will detect the error
# Before the test, we make a .tested and a .failed file. If
# the test succeeds, we remove the .failed file.
# find . -name '*.tested'
# and
# find . -name '*.failed'
# will summarize what you tested and what failed
##############################################################
%.test: $(OBJDIR)

%$(PINTOOL_SUFFIX).test : $(OBJDIR)%$(PINTOOL_SUFFIX) %.tested %.failed 
	touch $<.makefile.copy; rm $<.makefile.copy
	$(PIN) -t $< -- $(TESTAPP) makefile $<.makefile.copy
	$(PIN_CMP) makefile $<.makefile.copy
	rm $<.makefile.copy; rm $(@:$(PINTOOL_SUFFIX).test=.failed)

# Some subdirectories do not want the $(PINTOOL_SUFFIX) in their test name.
%.test : $(OBJDIR)%$(PINTOOL_SUFFIX) %.tested %.failed
	touch $<.makefile.copy; rm $<.makefile.copy
	$(PIN) -t $< -- $(TESTAPP) makefile $<.makefile.copy
	$(PIN_CMP) makefile $<.makefile.copy
	rm $<.makefile.copy; rm $(@:.test=.failed)


%.tested :
	touch $@

%.failed :
	touch $@

# otherwise these are deleted if the tool build fails
.PRECIOUS : %.tested %.failed

all:

.PHONY: dir
dir: 
	mkdir -p $(OBJDIR)

